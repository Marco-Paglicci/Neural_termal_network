import yaml
import cv2
import albumentations as A
from pathlib import Path

# 1️⃣ Leggi dataset.yaml per individuare train/images e train/labels
cfg = yaml.safe_load(open("dataset.yaml"))
base = Path(cfg["path"])
img_dir = base / cfg["train"]
lbl_dir = base / Path(cfg["train"].replace("images", "labels"))

# 2️⃣ Prepara directory di output
out_base = base / "augmented"
out_img = out_base / "train/images"
out_lbl = out_base / "train/labels"
out_img.mkdir(parents=True, exist_ok=True)
out_lbl.mkdir(parents=True, exist_ok=True)

# 3️⃣ Definisci pipeline Albumentations
transform = A.Compose([
    A.RandomRotate90(p=0.5),
    A.HorizontalFlip(p=0.5),
    A.BBoxSafeRandomCrop(p=2.0),
], bbox_params=A.BboxParams(format="yolo", label_fields=["class_labels"] , min_visibilty=0.1))

N_AUG = 5  # numero di augment per immagine

# 4️⃣ Loop su tutte le immagini di train
for img_path in img_dir.glob("*.*"):
    img = cv2.imread(str(img_path))
    lbl_path = lbl_dir / f"{img_path.stem}.txt"
    if not lbl_path.exists(): 
        continue

    # Leggi bounding box e classi
    with open(lbl_path) as f:
        data = [line.split() for line in f.read().splitlines()]
    boxes = [[float(x) for x in line[1:]] for line in data]
    classes = [int(line[0]) for line in data]

    # Genera augmentazioni
    for i in range(N_AUG):
        aug = transform(image=img, bboxes=boxes, class_labels=classes)
        new_name = f"{img_path.stem}_aug{i}{img_path.suffix}"
        cv2.imwrite(str(out_img/new_name), aug["image"])

        # Salva label YOLO
        with open(out_lbl/f"{Path(new_name).stem}.txt", "w") as f:
            for cls, box in zip(aug["class_labels"], aug["bboxes"]):
                f.write(f"{cls} {' '.join(f'{coord:.6f}' for coord in box)}\n")
